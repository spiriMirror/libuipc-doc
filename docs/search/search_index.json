{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"libuipc","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The libuipc is a C++ library that provides A Unified Incremental Potential Contact Framework for simulating the dynamics of rigid bodies, soft bodies, cloth, threads, and so on with penetration-free accurate contact.</p> <p>The libuipc is designed for the development of physics-based simulation software, such as video games, virtual reality applications, robotics applications, and so on. </p> <p>The libuipc is easy to use, high-performance, robust, and highly extensible.</p> <ul> <li> <p>Easy to use: </p> <ul> <li>The libuipc provides a simple and intuitive API at the frontend, which allows users to easily create and simulate complex physical scenes and seemlessly change the backend implementation without changing the frontend code.</li> <li>The libuipc provides Python bindings, which allows users to use the libuipc frontend in python.</li> </ul> </li> <li> <p>High performance:</p> <ul> <li>The libuipc backends are implemented and optimized with Multi-threading, SIMD, and GPU acceleration, which can achieve high performance on modern multi-core CPUs and GPUs.</li> <li>The supported backends include:<ul> <li>CUDA GPU backend</li> <li>TBB CPU backend</li> <li>... [TODO]</li> </ul> </li> </ul> </li> <li> <p>Robust:</p> <ul> <li>The libuipc is designed to be robust and stable, which can handle complex physical scenes with fully controllable accuracy.</li> <li>The libuipc system design has high isolation between different modules, which can prevent the error propagation between different subsystems.</li> </ul> </li> <li> <p>Highly extensible:</p> <ul> <li>The libuipc is highly modular, which allows users to easily extend the libuipc with new features.</li> <li>It allows users to add their own custom collision detection algorithms, custom constraints, custom integrators, custom solvers, custom energy functions, and so on.</li> <li>Embedded Python scripting is supported (maybe based on Numba), which allows users to easily add custom behaviors to the simulation.</li> </ul> </li> </ul>"},{"location":"nav/","title":"Nav","text":"<ul> <li>Home</li> <li>Tutorial<ul> <li>Geometry</li> <li>Scene</li> </ul> </li> <li>Specification<ul> <li>Implicit Geometry UID</li> <li>Implicit Geometries</li> <li>Constitution UID</li> <li>Constitutions</li> </ul> </li> <li>Libuipc API Documentation<ul> <li>Annotated</li> <li>Files</li> <li>Namespaces</li> <li>Classes</li> <li>Class Hierarchy</li> <li>Modules</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enums</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enums</li> <li>Functions</li> <li>Macros</li> <li>Variables</li> </ul> </li> <li>Development</li> <li>Misc</li> </ul>"},{"location":"development/","title":"Development","text":"<p>This document describes the design and implementation of the <code>libuipc</code>, providing a reference for developers who wish to contribute to the project. Here, we will mainly focus on the backend implementation of the framework.</p>"},{"location":"development/#formalized-unified-incremental-potential-contact","title":"Formalized Unified Incremental Potential Contact","text":"<p>In this section, we describe the Unifed Incremental Potential Contact (UIPC) Framework in a mathmatical way to provide a formalized definition of the framework. Some of the terminology defined in this section may be used throughout the rest of the document.</p> <p>Note</p> <p>It's highly recommended to read this section before reading the rest of the document.</p>"},{"location":"development/#data-oriented-programming","title":"Data Oriented Programming","text":"<p>The Partial Differential Equation (PDE) of the simulation problem is already an abstract representation of the real world. We don't need to make any conceptual abstraction using Object Oriented Programming (OOP) to represent the objects. Instead, we keep Data Oriented Programming (DOP) in mind to represent the data in a way that is cache-friendly and efficient. In some way, we organize the UIPC framework in a modified Entity Component System (ECS) pattern, which is called the Reporter-Manager-Receiver (RMR) model.</p>"},{"location":"development/#reporter-manager-receiver-model","title":"Reporter-Manager-Receiver Model","text":"<p>The model is a conceptual design pattern that organizes the data flow between different components of the framework in a safe, cache-friendly and flexible way.</p> <p></p>"},{"location":"misc/3rd_libs/","title":"fmt","text":"<ul> <li>Format User Type</li> </ul>"},{"location":"specification/","title":"Libuipc Specification","text":"<p>This document, referred to as the \"libuipc Specification\" defines the behavior of the library.</p>"},{"location":"specification/constitution_uid/","title":"Constitution UID","text":"<p>The Constitution UID is a unique identifier for a constitution known by <code>libuipc</code>, which is a 64-bit unsigned integer. </p> <p>The official constitution UID has a range of \\([0, 2^{32}-1]\\). The range \\([2^{32}, 2^{64}-1]\\) is reserved for user-defined constitutions.</p> <p>Every official constitution will be documented in this specification. A user-defined constitution can apply for an official constitution UID by submitting a pull request to the <code>libuipc</code> repository, After code review, the constitution will be added to the official constitution list.</p> <p>The official constitution UID is defined in the <code>uipc/builtin/constitution_uid.h</code> file. </p> <p>The related documentation of the constitution will be added to the Constutitions/ directory.</p> <p>When applying a constitution to a geometry, the <code>constitution_uid</code> attribute of the <code>meta</code> attribute of the geometry will be set to the constitution UID. The backend will use this UID to determine the constitution of the geometry.</p>"},{"location":"specification/implicit_geometry_uid/","title":"Implicit Geometry UID","text":"<p>The Implicit Geometry UID is a unique identifier for an implicit geometry known by <code>libuipc</code>, which is a 64-bit unsigned integer.</p> <p>The official implicit geometry UID has a range of \\([0, 2^{32}-1]\\). The range \\([2^{32}, 2^{64}-1]\\) is reserved for user-defined implicit geometries.</p> <p>Every official implicit geometry will be documented in this specification. A user-defined implicit geometry can apply for an official implicit geometry UID by submitting a pull request to the <code>libuipc</code> repository, After code review, the implicit geometry will be added to the official implicit geometry list.</p> <p>The official implicit geometry UID is defined in the <code>uipc/builtin/implicit_geometry_uid.h</code> file.</p> <p>The related documentation of the implicit geometry will be added to the Implicit Geometries/ directory.</p> <p>When creating a implicit geometry, the <code>implicit_geometry_uid</code> attribute of the <code>meta</code> attribute of the geometry will be set to the implicit geometry UID. The backend will use this UID to determine the implicit geometry of the geometry, and try to find the related coefficients from the attributes of the geometry (in <code>meta</code> or <code>instances</code>).</p>"},{"location":"specification/constitutions/","title":"Constitutions","text":"UID Friendly Name Description 0 Empty Preserved 1-8 AffineBody Affine Body Preserved Constitutions"},{"location":"specification/constitutions/affine_body/","title":"Affine Body","text":"<p>This page registers the Affine Body constitution.</p>"},{"location":"specification/implicit_geometries/","title":"Implicit Geometry","text":"UID Friendly Name Description 0 Empty Preserved 1 HalfPlane Half Plane"},{"location":"specification/implicit_geometries/half_plane/","title":"Half Plane","text":""},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#quick-start","title":"Quick Start","text":""},{"location":"tutorial/#understanding-the-basics","title":"Understanding the Basics","text":""},{"location":"tutorial/geometry/","title":"Geometry","text":"<p>In simulation programs, geometry is a fundamental concept to represent the shape of the object, or rigrously, the domain of the simulation. </p> <p>There are several kinds of geometry, such as point cloud, line mesh, triangle mesh, quad mesh, polygon mesh, tetrahedral mesh, hexahedral mesh and so on, these geometries are called explicit geometries, because we use a discrete set of vertices and primitives to represent the geometry. There are also some implicit geometries, such as the Signed Distance Field (SDF), which is a scalar field that represents the distance from the point to the surface of the geometry. It's inrealistic and inpractical to represent all the geometries in a single way, so we separate the geometries into several categories, and provide proper interfaces to access the relative information of the geometry.</p> <p>They are:</p> <ul> <li>Simplicial Complex: A unified representation of the explicit geometries, whose primitives are simplices, such as point, line, triangle, tetrahedron, etc. Some examples are point cloud, line mesh, triangle mesh, tetrahedral mesh, etc.</li> <li>Quad Mesh: A 2D mesh whose primitives are quadrilaterals, which is commonly used in the simulation of cloth.</li> <li>Implicit Geometry: A presentation of the implicit geometries, such as the Signed Distance Field (SDF).</li> </ul> <p>In this tutorial, we fill focus on the simplicial complex, which is the most common geometry in the simulation programs. And describe the geometry interface in the <code>libuipc</code> library.</p>"},{"location":"tutorial/geometry/#what-makes-a-geometry","title":"What makes a geometry?","text":"<p>The first question to come is what makes a geometry?</p> <p>Our answer is:</p> \\[ \\text{Geometry} = \\text{Topology} + \\text{Attributes} \\] <p>Topologies describe how a geometry is connected, and attributes who have the same dimension as the topology carry the information of the geometry.</p> <p>For example, to represent a 2D surface in a triangle mesh (like famous <code>.obj</code> format), we store the positions of the vertices and the triangles that connect the vertices, as shown below:</p> \\[ V = \\{ 0,1,...,N-1 \\}, \\] <p>where \\(V\\) is the set of vertices, and \\(N\\) is the number of vertices.</p> <p>We may store the positions of the vertices with the same count as the vertices:</p> \\[ P = \\{ \\mathbf{x}_i\\mid i \\in V \\}, \\] <p>To represent the triangle, we may store the indices of the vertices that form the triangle:</p> \\[ F = \\{ (i,j,k) \\mid i,j,k \\in V \\}. \\] <p>If we want to record the area of each triangle, we may store a float number for each triangle:</p> \\[ A = \\{ a_{ijk} \\mid (i,j,k) \\in F \\}. \\] <p>In this example, the topology is the set of vertices \\(V\\) and triangles \\(F\\), and the attributes are the positions \\(P\\) of the vertices and the area \\(A\\) of the triangles, which obey the rule:</p> \\[ |P| = |V|, |A| = |F|, \\] <p>where \\(|\\bullet|\\) tells the element count of the set.</p> <p>With the same basic idea, we use a more general and well-defined way to represent such kind of geometry in the <code>libuipc</code> library, called Simplicial Complex, which is widely used in the diserete differential geometry.</p>"},{"location":"tutorial/geometry/#simplicial-complex","title":"Simplicial Complex","text":"<p>In <code>libuipc</code>, a <code>Simplicial Complex</code> is a general representation of an explicit mesh. In \\(\\mathbb{R}^3\\), a simplicial complex can be a tetrahedral mesh, a triangle mesh, a line mesh, or a point cloud, which have a dimension of 3, 2, 1, or 0, respectively.</p> <p>The tetrahedral mesh can be used to describe solid objects, like a bus, boxes ...</p> <p>[TODO: add some solid object figure]</p> <p>The triangle mesh can be used to describe some 2D-codimensional objects, like a cloth with a thin thickness.</p> <p>[TODO: add some cloth figure]</p> <p>The line mesh can be used to describe some 1D-codimensional objects, like a rope, a curve, or a wire.</p> <p>[TODO: add some rope figure here]</p> <p>The point cloud can be used to describe some 0D-codimensional objects, like a bunch of particles.</p> <p>[TODO: add some particle figure here]</p> <p>The simplest way to create a simplicial complex is to use the <code>geometry::tetmesh()</code>, <code>geometry::trimesh()</code>, <code>geometry::linemesh()</code>, and <code>geometry::pointcloud()</code> functions, (<code>#include &lt;uipc/geometry/factory.h&gt;</code>), which are shown below: <pre><code>auto tetmesh = geometry::tetmesh(Vs,Ts);\ntetmesh.dim(); // 3\nauto trimesh = geometry::trimesh(Vs,Fs);\ntrimesh.dim(); // 2\nauto linemesh = geometry::linemesh(Vs,Es);\nlinemesh.dim(); // 1\nauto pointcloud = geometry::pointcloud(Vs);\npointcloud.dim(); // 0\n</code></pre></p> <p>Or, you want to read the meshes from a file, you can <code>#include &lt;uipc/geometry/io.h&gt;</code>, and call the related functions: <pre><code>SimplicialComplexIO io;\n// .msh file\nauto tetmesh = io.read(\"bunny.msh\");\n// .obj file\nauto trimesh = io.read(\"cloth.obj\");\n// ... any other supported file format\n</code></pre></p>"},{"location":"tutorial/geometry/#access-geometry-information","title":"Access Geometry Information","text":"<p>In <code>libuipc</code>, the data access and memory ownership of the geometry are separated. You can notice such a design almost everywhere in the library.</p> <p>To access the geometry information, you need to create a view of the geometry, which is a lightweight object indicating the way we access the geometry, typically the read-only or read-write. </p> <p>For example, now we have a cube.</p> <pre><code>SimplicialComplexIO io;\nauto cube = io.read(\"cube.msh\");\n</code></pre> <p>To access the positions of the cube, we need to find the attribute of the positions, which is a vector of the <code>Vector3</code> type.</p> <pre><code>auto VA = cube.vertices();\nauto pos = VA.find&lt;Vector3&gt;(\"position\");\n</code></pre> <p>Note that, till now, we just get a handle of the attribute \"position\". To access the data, we need to create a view of the attribute.</p> <pre><code>span&lt;const Vector3&gt; view = pos-&gt;view();\n</code></pre> <p>The view of the position is a <code>span&lt;const Vector3&gt;</code> (we explicitly define it here, but you can use <code>auto</code>), which is a const view of the position data. You can not modify the data through the view.</p> <p>If you want to modify the position data, you can create a non-const view of the attribute.</p> <p><pre><code>span&lt;Vector3&gt; non_const_view = geometry::view(*pos);\n</code></pre> You find that, it need more effort to create a non-const view of the attribute (calling the global function <code>geometry::view</code>) than creating a const view(calling the member function <code>view</code> of the attribute). This is because we want to make sure that the user is aware of the potential clone of the geometry when they modify the data. The non-const view assumes that you may modify the data, which may trigger a clone of the geometry according to <code>libuipc</code>'s Clone on Write strategy.</p> <p>Now, you can print the positions of the cube.</p> <pre><code>for (auto&amp;&amp; p : view) std::cout &lt;&lt; p &lt;&lt; std::endl;\n</code></pre> <p>You may want to access the tetrahedra topology of the cube, which is similar to the positions.</p> <pre><code>auto TA = cube.tetrahedra();\nspan&lt;Vector4i&gt; tet_view = geometry::view(TA.topo());\nspan&lt;const Vector4i&gt; ctet_view = TA.topo().view();\n</code></pre> <p>But because the topology is already there, we don't need to <code>find</code> anything. Also, if you just want to read the topology, it's better to use the const view.</p> <p>To create a new attribute, you can call the <code>create</code> function, with the attribute name and the default value.</p> <pre><code>auto vel = VA.create&lt;Vector3&gt;(\"velocity\", Vector3::Zero());\n</code></pre> <p>Then we will have a new attribute named \"velocity\" with the default value <code>Vector3::Zero()</code>, the size of the attribute is the same as the number of vertices.</p> <p>To remove an attribute, you can call the <code>destroy</code> function with the attribute name.</p> <pre><code>VA.destroy(\"velocity\");\n</code></pre> <p>Danger</p> <p>Accessing the removed attribute slot will cause the program to crash.</p> <p>If you are not sure whether the attribute slot is valid, you should check it by:</p> <p><pre><code>if(vel)\n{\n    // do something\n}\n</code></pre> The <code>vel</code> is a kind of weak pointer, which will be <code>nullptr</code> if the attribute slot is invalid.</p> <p>Ok, now you have a basic idea of how to access the geometry information. Let's move on to the next section. I think it's high time to show the so called <code>Clone on Write</code> strategy.</p>"},{"location":"tutorial/geometry/#clone-on-write","title":"Clone on Write","text":"<p>Geometries in <code>libuipc</code> are implemented with the <code>Clone on Write</code> strategy. Any inital copy of a geometry is a shallow copy, which means, the data of the geometry is shared. Any creation of a non-const view of the geometry will trigger a minimal clone of the modified part of the geometry.</p> <p>A simple example is shown below: <pre><code>auto foo = geometry::tetmesh(Vs,Ts);\nauto bar = foo;\n</code></pre> Here, <code>bar</code> is just a shallow copy of the <code>foo</code>. No matter <code>bar</code> or <code>foo</code> is modified, the related internal part of the data will be cloned.</p> <p>For example, we create a non-const view of the positions of the mesh <code>bar</code>: <pre><code>auto VA  = bar.vertices();\nauto pos = VA.find&lt;Vector3&gt;(\"position\");\npos-&gt;is_shared(); // true\nauto non_const_view = pos-&gt;view();\npos-&gt;is_shared(); // false\n</code></pre> Here, <code>pos-&gt;is_shared()</code> first return <code>true</code>, which means the position data is shared. After we create a non-const view of the position data, <code>pos-&gt;is_shared()</code> will return <code>false</code>, which means, <code>pos</code> is exclusively belong to <code>bar</code>. <pre><code>TA = bar.tetrahedra();\nTA.topo().is_shared(); // true\n</code></pre> Here, <code>TA.topo().is_shared()</code> will return <code>true</code>, because we don't modify the topology, so the topology of <code>foo</code> and <code>bar</code> is still shared.</p> <p>Such a design minimizes the geometry memory usage.</p> <p>Warning</p> <p>Be careful when you create a view of the geometry. Always use a const view if you don't want to modify the data to gain higher performance.</p> <p>Danger</p> <p>Never store a view of any attribute, because the view may become invalid after the attribute is modified. Always create a new view when you need it.</p>"},{"location":"tutorial/geometry/#instancing-and-meta-information","title":"Instancing and Meta Information","text":"<p>In the field of rendering, instancing is a common technique to render multiple instances of the same geometry with different transformations, which is very efficient to desribe the scene with many similar objects.</p> <p>To get the instance information of the geometry, you can call the <code>instances()</code> function of the geometry, almost the same as the <code>vertices()</code> and <code>tetrahedra()</code> functions.</p> <pre><code>SimplicialComplexIO io;\nauto cube = io.read(\"cube.msh\");\nauto Is = cube.instances();\nIs.size(); // 1\n</code></pre> <p>A geometry is initally a single instance, so the size of <code>Is</code> is excatly 1.</p> <p>To create instances, you just resize it.</p> <pre><code>Is.resize(5);\nIs.size(); // 5\n</code></pre> <p>Now, you have 5 instances of the cube.</p> <p>You may ask for the transformation of the instances, the answer is the same as the positions and the tetrahedra.</p> <pre><code>auto trans = Is.find&lt;Matrix4x4&gt;(\"transform\");\nauto trans_view = trans-&gt;view();\nfor(auto&amp;&amp; t : trans_view) std::cout &lt;&lt; t &lt;&lt; std::endl;\n</code></pre> <p>There are some short-cut you can take to access some common attributes of the geometry, such as the positions, the transforms, etc.</p> <pre><code>auto&amp; short_cut_trans = Is.transforms();\nauto&amp; short_cut_pos = cube.positions();\n</code></pre> <p>The naming convention of the short-cut is the plural form of the attribute name, which is more readable and more intuitive.</p> <p>Destroying the short-cut is not allowed, if you do so, <code>libuipc</code> will throw an exception.</p> <pre><code>Is.destroy(\"transform\"); // throw AttributeDontAllowDestroy\n</code></pre> <p>To get the meta information of the geometry, you can call the <code>meta()</code> function of the geometry.</p> <pre><code>auto&amp; meta = cube.meta();\n</code></pre> <p>The way to access the meta information is the same as all the other attributes. The only difference is that the meta information is a \"demension 1\" attribute, which means, the meta information always has a size of 1, you can create attributes, but you can not resize it. The the meta describes the root information of the geometry. For example, you can create a meta attribute to store the name of the geometry.</p> <pre><code>auto name = meta.create&lt;std::string&gt;(\"name\", \"some cubes\");\n</code></pre>"},{"location":"tutorial/geometry/#quad-mesh","title":"Quad Mesh","text":"<p>[TODO]</p>"},{"location":"tutorial/geometry/#implicit-geometry","title":"Implicit Geometry","text":"<p>[TODO]</p>"},{"location":"tutorial/scene/","title":"Scene","text":"<p>Scene in <code>libuipc</code> is a whole set of entities that we want to simulate.</p> <p>Here is an illustration of a scene in <code>libuipc</code>. It might look a little bit complicated, but don't worry, we will explain it step by step.</p> <p></p> <p>There are 4 main parts in a scene:</p> <ul> <li>Objects are some concrete entities, such as a T-shirt, a box, etc. They may can be described by a set of geometries. For example, a T-shirt may have several pieces of cloth, producted by different materials (constitutions) and have different contact behaviors (contact models).</li> <li>Geometries are all the basic geometries that are used to build objects in the scene. The ownership of the geometries is kept by the scene.</li> <li>Constitution tabular is a collection of all the constitutions that are used in the scene. A constitution is a set of properties that define the physics behavior of the object. For example, a famous constitution is the Neo-Hookean model, which is used to simulate the deformation of rubber-like materials.</li> <li>Contact tabular is a collection of all the contact models that are used in the scene. A contact model is a set of properties that define the contact behavior of the object. Typically, the properties include the friction coefficient, the restitution coefficient, etc.</li> </ul> <p>Here is a simple example to create a scene:</p> <p>First, we declare a scene. <pre><code>world::Scene scene;\n</code></pre> We need to create a constitution for the object. Here we use the <code>AffineBodyConstitution</code> as an example, <code>AffineBodyConstitution</code> is a simple constitution that can be used to approximate the behavior of a rigid body. <pre><code>auto&amp; constitution_tabular = scene.constitution_tabular();\n// create a constitution\nauto&amp; abd = constitution_tabular.create&lt;AffineBodyConstitution&gt;();\n// create a material with affine body stiffness 1e8 Pa\nauto abd_material = abd.create_material(1e8 /*Pa*/);\n</code></pre> To simulate the contact behavior of the object, we need to create a contact model. Note that the contact model has a pairwised relationship. For example, a contact tabular among wood, steel, and rubber can be defined as follows (imaginary values, just for demonstration):</p> fric wood steel rubber wood 0.5 0.3 0.6 steel - 0.2 0.4 rubber - - 0.7 <pre><code>auto&amp; contact_tabular = scene.contact_tabular();\n// create a contact element\nauto&amp; wood_contact = contact_tabular.create(\"wood\");\n// create self-contact model\n// friction coefficient is 0.5, restitution coefficient is 1e8\ncontact_tabular.insert(wood_contact, wood_contact, 0.5, 1e8);\n</code></pre> <p>Now we can create a wooden cube object in the scene. <pre><code>// read a cube mesh from file\nSimplicialComplexIO io;\nauto cube = io.read(\"cube.msh\");\n\n// apply the material and the contact model to the cube\nabd_material.apply_to(cube);\nwood_contact.apply_to(cube);\n\n// create an object\nauto wooden_cube = scene.objects().create(\"wooden_cube\");\n\n// create a geometry for the object\nwooden_cube-&gt;geometries().create(cube);\n</code></pre></p> <p>A short summary of creating a scene:</p> <ol> <li>setup the constitution tabular</li> <li>setup the contact tabular</li> <li>apply constitutions and contact elements to the geometries</li> <li>create objects</li> </ol>"},{"location":"tutorial/scene/#object","title":"Object","text":"<p>Object in <code>libuipc</code> is a representation of the concrete entity in real world. It is something that touchable, visible, and can be interacted with. An object can be composed of one or more geometries, and each geometry can have its own constitution and contact model. </p> <p>Though a geometry share the same constitution and contact model, the coefficients of the constitution and the contact model can be different in the geometry. Some random perturbation can be added to the related attributes of the geometry to simulate the real world.</p> <p>Info</p> <p>The coefficients of the constitution and the contact model can be stored in the attributes of the geometry. The backend can retrieve the coefficients from the attributes and simulate them properly.</p>"},{"location":"tutorial/scene/#constitution","title":"Constitution","text":"<p>Constitution is a set of coefficients and models that define the physics behavior of the object. Because there are so many different constitutions so far, we use a Consititution UID to identify all the constitutions <code>libuipc</code> supports. The specification of the constitutions can be found here.</p> <p>For coding convenience, we provide some class like <code>AffineBodyConstitution</code> to help the user create a constitution. </p>"},{"location":"tutorial/scene/#material","title":"Material","text":"<p>Material is an instance of a constitution. A material has a concrete set of coefficients that define the physics behavior of the object. And it may be a short cut to apply the coefficients to the geometry.</p>"},{"location":"tutorial/scene/#contact-model","title":"Contact Model","text":"<p>Contact model is a set of coefficients and models that define the contact behavior of the object. The contact model is a pairwised relationship, which means the contact model between two objects is different from the contact model between another two objects.</p>"},{"location":"tutorial/scene/#contact-element","title":"Contact Element","text":"<p>A contact element is one side of the pairwised contact model, which has no meaning itself. The contact element ID of two objects that are in contact with each other are used to find the contact model between them.</p> <pre><code>wood_contact.id(); // 1\n</code></pre> <p>Note that, <code>wood_contact</code> element id is <code>1</code>, because there is a default contact element with id <code>0</code>. The default contact model will be a fallback when the contact model between two objects is not defined.</p> <p>[Discussion] Do we need to provide a <code>ContactModelUID</code> to identify the contact model? Because in GIPC we have new contact model based on an anisotropic constitutions.</p>"},{"location":"Libuipc/annotated/","title":"Class List","text":"<p>No classes, structs, unions or interfaces found.</p>"},{"location":"Libuipc/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p>"},{"location":"Libuipc/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"Libuipc/classes/","title":"Class Index","text":""},{"location":"Libuipc/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>"},{"location":"Libuipc/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Libuipc/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Libuipc/class_members/","title":"Class Members","text":"<p>Nothing related to Class Members found.</p>"},{"location":"Libuipc/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"Libuipc/class_member_variables/","title":"Class Member Variables","text":"<p>Nothing related to Class Member Variables found.</p>"},{"location":"Libuipc/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Libuipc/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Libuipc/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Libuipc/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Libuipc/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Libuipc/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Libuipc/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Libuipc/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"Libuipc/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"Libuipc/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"Libuipc/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}